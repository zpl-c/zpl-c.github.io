{"pageProps":{"post":{"title":"librg - one month update!","date":"2017-10-11T00:00:00.000Z","slug":"librg-one-month-update","author":"inlife","content":"<p>Welcome everybody to our second post!</p>\n<p>First of all we would like to give you guys updates about our current status, and what we have been doing for the past month. And oh boy, that was one hell of a month!</p>\n<p>Lest start with nice list of things that we planned to do:</p>\n<ul>\n<li>Multi-threaded world reconstruction.</li>\n<li>Re-visit and revamp all memory allocation strategies.</li>\n<li>Add support of entity cooling, decreasing the number of updates sent.</li>\n<li>Add ability to reject all possible built-in events.</li>\n<li>Add fields: peer and \"custom\" pointer to the event structure, possibly giving them more potential.</li>\n<li>Consider single-var context representation and context switching.</li>\n<li>Add more assertions to possible user inputs.</li>\n<li>And of course various performance optimizations.</li>\n</ul>\n<p>So, concluding the list above, we had 2 major tasks, refactor the library, to support contexts, or in other words, make it thread-safe. And second one, refactor the component system. The component system refactor was not actually mentioned above, but it was needed due to context implementation, and the way how components worked before.</p>\n<pre><code class=\"language-c\">#define LIBRG_IMPLEMENTATION\n#define LIBRG_DEBUG\n#include &#x3C;librg.h>\n\ntypedef struct { u32 bar; } foo;\n\nvoid custom_components(librg_ctx_t *ctx) {\n    librg_component_register(ctx, librg_component_last, sizeof(foo));\n}\n\nvoid on_connect_accepted(librg_event_t *event) {\n    librg_log(\"someone connected to the server!\\n\");\n}\n\nint main() {\n    // initialization\n    librg_ctx_t ctx = {0};\n\n    ctx.tick_delay   = 32;\n    ctx.mode         = LIBRG_MODE_SERVER;\n    ctx.world_size   = zplm_vec3(5000.0f, 5000.0f, 0.0f);\n\n    librg_init(&#x26;ctx, custom_components);\n\n    // adding event handlers\n    librg_event_add(&#x26;ctx, LIBRG_CONNECTION_ACCEPT, on_connect_accepted);\n\n    // starting server\n    librg_address_t address = {0}; address.port = 27010;\n    librg_network_start(&#x26;ctx, address);\n\n    // starting main loop (run 100 times for test)\n    for (int i = 0; i &#x3C; 100; ++i) {\n        librg_tick(&#x26;ctx);\n        zpl_sleep_ms(1);\n    }\n\n    // stopping network and freeing resources\n    librg_network_stop(&#x26;ctx);\n    librg_free(&#x26;ctx);\n\n    return 0;\n}\n</code></pre>\n<p>New component system has a few benefits, comparing it to old one, such as: the core implementation is macro-less now (previous one required you to use macro constructions to generate needed methods for the needed component), it is slightly faster, and the most important thing is, it is possible to bind component methods to the different scripting languages/implementations now. We also got rid of so-called, lazy-initialization for component pools, which makes your memory consumption increase somewhat unexpected for occasions when your are not really familiar with what is going on under the hood.</p>\n<p>Next thing - context implementation.\nThe idea is simple, and you saw it in the most of proper-made C libraries out-there: provide context to each method. So this is basically exactly what we did. Updating method-API part, changing data structures, and re-organizing code inside implementation part, to make everything work simply, and nicely.</p>\n<blockquote>\n<p>Why do you need contexts, you can ask, they are just making the interface more complicated!</p>\n</blockquote>\n<p>Well it's a good question, first of all, with our previous approach you wouldn't be able to run multiple instances of librg inside one thread, and making let's say a server-client app/game bundled inside one application and inside one thread would be impossible.</p>\n<p>As soon as we finished those 2 things mentioned above, we wanted to check, how hard it would be to create a bindings for the library, so we made librg-odin. And then we stared doing performance optimizations, decreasing amount of time needed for creation of update packet for each client.</p>\n<p><img src=\"https://dl.dropboxusercontent.com/s/rgd0vuqyfop81kf/sublime_text_2017-10-03_16-52-17.png\" alt=\"\"></p>\n<p>We started from around point of 300 ms per update for 1k connected clients + 10k entities, and successfully decreased the update time to only 10-20 ms per update for same conditions by making optimizations for cycles, minimizing repeated memory allocations, etc. And, the most important, adding support for multi-threaded update and entity culling insertion, which made the most significant difference.</p>\n<p>We are currently also experimenting with world graph modification, to avoid re-constructing our k-d tree each time server updates our entities. This feature is currently volatile and requires further polishing, it may or may not be available in the 3.0 release.</p>\n<p>All these changes lead to our new version 3.0.\nCurrently, we are still busy finishing some things, but we hope that we will be able to switch to 3.0 and mark it as stable within this month.</p>\n<p>You can check out <strong>librg</strong> by following <a href=\"https://github.com/zpl-c/librg\">this link</a>.</p>\n<p>Thank you for reading!</p>\n"}},"__N_SSG":true}