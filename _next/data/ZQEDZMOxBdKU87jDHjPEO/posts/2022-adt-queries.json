{"pageProps":{"post":{"title":"ADT queries!","date":"2022-06-09T00:00:00.000Z","slug":"2022-adt-queries","author":"zaklaus","content":"<p>Hi there!</p>\n<p>With the release of <a href=\"https://github.com/zpl-c/zpl/releases/tag/16.1.1\">16.1.1</a> version of zpl you are now able to perform URI like queries on ADT nodes.</p>\n<p>The new function <code>zpl_adt_get</code> takes a URI which specifies how we should perform a lookup on an ADT node. The following features are present:</p>\n<ul>\n<li>nested lookup\n<ul>\n<li><code>a/b/c</code> would look through nodes to fetch the <code>c</code> node.</li>\n</ul>\n</li>\n<li>nested conditional lookup\n<ul>\n<li><code>arr/[foo=123]/bar</code> would scan the <code>arr</code> array node to find an object element which field <code>foo</code> would be of value <code>123</code>, it would then fetch a node inside called <code>bar</code>.</li>\n</ul>\n</li>\n<li>index-based lookup\n<ul>\n<li><code>arr/3</code> would fetch the 4th element of array node <code>arr</code>.</li>\n</ul>\n</li>\n<li>value-based lookup\n<ul>\n<li><code>arr/[apple]</code> would fetch an element of array node <code>arr</code> with value <code>apple</code>.</li>\n</ul>\n</li>\n</ul>\n<p>The following code showcases this new feature:</p>\n<pre><code class=\"language-c\">#define ZPL_IMPLEMENTATION\n#define ZPL_NANO\n#define ZPL_ENABLE_PARSER\n#include &#x3C;zpl.h>\n\nint main(void) {\n    zpl_file_contents fc;\n    fc = zpl_file_read_contents(zpl_heap(), true, \"misc/data/glsl_diffuse.json5\");\n\n    zpl_json_object root = {0};\n\n    zpl_u8 err;\n    err = zpl_json_parse(&#x26;root, (char *)fc.data, zpl_heap_allocator());\n    zpl_printf(\"Error code: %d\\n\", err);\n\n    zpl_json_object *nested_node_variant = zpl_adt_get(&#x26;root, \"layer1/layer2/layer3\");\n    ZPL_ASSERT_NOT_NULL(nested_node_variant);\n    ZPL_ASSERT(nested_node_variant->integer == 42);\n\n    zpl_json_object *def_value_node = zpl_adt_get(&#x26;root, \"uniforms/[name=distort]/layout/[pos=y]/default_value\");\n    ZPL_ASSERT_NOT_NULL(def_value_node);\n\n    zpl_json_object *num_42_node = zpl_adt_get(&#x26;root, \"numbers/[value=42]\");\n    ZPL_ASSERT_NOT_NULL(num_42_node);\n\n    zpl_json_object *arr_idx_node = zpl_adt_get(&#x26;root, \"array/3\");\n    ZPL_ASSERT_NOT_NULL(arr_idx_node);\n    ZPL_ASSERT(arr_idx_node->integer == 4);\n\n    zpl_json_object *arr_val_node = zpl_adt_get(&#x26;root, \"array/[4]\");\n    ZPL_ASSERT_NOT_NULL(arr_val_node);\n\n    zpl_json_free(&#x26;root);\n    zpl_file_free_contents(&#x26;fc);\n    return 0;\n}\n</code></pre>\n<p>We also plan to implement a sscanf alike addition to this API later on, stay tuned!</p>\n<p>See you next time!</p>\n"}},"__N_SSG":true}